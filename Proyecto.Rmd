---
title: "Proyecto "
author: "Joshua Cervantes/Moisés Monge"
date: "`r format(Sys.time(), '%d %B %Y')`"
mail: "joshua.cervantes@ucr.ac.cr"
linkedin: ""
twitter: ""
github: "afr063426"

home: ""
# !!! You need to provide a logo image here !!! Or just delete the field for no logo
logo: ""
output:
  prettydoc::html_pretty:
      theme: cayman
      highlight: github
      math: katex
      toc: true
      toc_depth: 2
      code_menu: true

---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, width = 60)
## Packages that are needed
#library(devtools)
library(prettydoc)
library(rmarkdown)
library(tidyverse)
library(kableExtra)
library(magrittr)
library(jcolors)
library(xtable)
library(RColorBrewer)
#library(rjags) #Gibbs method
#library(ecoforecastR) #This packages can be used to model with Bayesian method
library(ggcorrplot)
library(dlm) #For space-state
options(scipen = 999, digits = 5)
#options(scipen = 999, digits = 5, OutDec = ",")
#setwd("C:/Users/saac9/OneDrive - Universidad de Costa Rica/Documents/UCR/2022/Modelos_Lineales/Proyecto_Mod_Lin")

#We comment beacuse only is needed to create the table
#used with all the stations
#---------------------------------------
# We write all the tables

#list_documents <- unlist(list.files(path="PRSA_Data_20130301-20170228",all.file=TRUE,full.names=TRUE))[-(1:2)]

#We proceed to join all in an unique file
#data <- read.csv(list_documents[1])
#for(i in list_documents[-1]){
#    aux <- read.csv(i)
#    data <- rbind(data,aux)
#}

#We write a document with all the stations
#write.csv(data, "datos.csv")
#-----------------------------------------
#We read the documento
data <- read.csv("datos.csv")
data<-data[-1]
data$station<-as.factor(data$station)
stations <- unique(data$station)
data%<>%mutate("Date"=as.Date(paste(year,month,day,sep="-"),format="%Y-%m-%d")) #Add date
```


```{r Table_Head}
#We create a table in format latex for the work

head_first_5 <- head(data, n=5)

print(xtable(head_first_5, type = "latex", tabular.environment="longtable"),
    include.rownames=FALSE, file = "head_5.tex")

```


```{r Summary_5}
#We create the summary of five numbers for 
#We select only the numeric kind
numeric_cols <- data%>%select_if(is.numeric)

#We select the first numeric that is considered important
n_col_PM2.5 <- which(colnames(numeric_cols)=="PM2.5")

#We select the last numeric that is considered important
n_col_WSPM <- which(colnames(numeric_cols)=="WSPM")


names_cols <- colnames(numeric_cols)

summary_5_number <- data.frame("Variable" = character(),
                "Mínimo"=numeric(), 
                "Q1"=numeric(),
                "Mediana"=numeric(),
                "Q3"=numeric(),
                "Máximo"=numeric()
                )


#Summary 5 numberts taking information of twelve stations
summary_data_frame <- function(dat){
    quantiles <- quantile(dat, na.rm = TRUE)
    quantiles <- data.frame("Mínimo"=quantiles[1], 
                "Q1"=quantiles[2],
                "Mediana"=quantiles[3],
                "Q3"=quantiles[4],
                "Máximo"=quantiles[5])
    return(quantiles)
}




for(i in n_col_PM2.5:n_col_WSPM){
    aux <- cbind("Variable" = names_cols[i], summary_data_frame(numeric_cols[i]))
    summary_5_number <- rbind(summary_5_number, aux)
}
#Data frame to long format


print(xtable(summary_5_number, type = "latex", tabular.environment="longtable"),
    include.rownames=FALSE, file = "summary_5_number.tex")


#We create a summary of five numbers for PM2.5 grouping by station

summary_2.5_station <- data.frame("Estación" = character(),
                "Mínimo"=numeric(), 
                "Q1"=numeric(),
                "Mediana"=numeric(),
                "Q3"=numeric(),
                "Máximo"=numeric()
                )
for(i in stations){
    PM2.5_aux <- data%>%filter(station == i)%>%select(PM2.5)
    aux <- cbind("Estación" = i, summary_data_frame(PM2.5_aux))
    summary_2.5_station <- rbind(summary_2.5_station, aux)
}
print(xtable(summary_2.5_station, type = "latex", tabular.environment="longtable"),
    include.rownames=FALSE, file = "summary_2.5_station.tex")

#Se elimina lo que no se va a volver a usar
rm(aux,head_first_5,numeric_cols,PM2.5_aux,summary_2.5_station,summary_5_number, i,k,n_col_PM2.5,n_col_WSPM,
   names_cols,intervalos,stations)
```




```{r}
#Frecuencia de lluvia
Frecuencia_lluvia<-data%>%select(RAIN,station)

#Se calcula la cantidad de clases que deberían haber
k<-nclass.Sturges(Frecuencia_lluvia$RAIN)

#Se contruyen los intervalos
intervalos<-cut(Frecuencia_lluvia$RAIN,breaks = seq(min(Frecuencia_lluvia$RAIN, na.rm = T),max(Frecuencia_lluvia$RAIN, na.rm = T),(max(Frecuencia_lluvia$RAIN, na.rm = T)-min(Frecuencia_lluvia$RAIN, na.rm = T))/k),right = F, na.rm = T, include.lowest = TRUE)

#Se le adjuntan los intervalos a la tabla que tenemos de anomalia y de region
Frecuencia_lluvia<-Frecuencia_lluvia%>%mutate(IntervaloLluvia=intervalos)

#Se genera la tabla de frecuencias

FA<-table(Frecuencia_lluvia$IntervaloLluvia,Frecuencia_lluvia$station)

#Se coloca la matriz en un Data Frame
FA<-as.data.frame(FA)
FA<-FA%>%spread(Var2,Freq)

FA<-rbind(FA, c("Total",colSums(Filter(is.numeric, FA))))

#Se contruye la tabla que va ser pasada a latex
print(xtable(FA, type = "latex", tabular.environment="longtable"),include.rownames=FALSE, file = "frecuenciaLluvia.tex")

#Se elimina la tabla que tiene las frecuencias segun temperatura y anomalia
rm(FA,Frecuencia_lluvia,intervalos)



```

```{r}
#Frecuencia de PM2
Frecuencia_PM2.5<-data%>%select(PM2.5,station)

#Se calcula la cantidad de clases que deberían haber
k<-nclass.Sturges(Frecuencia_PM2.5$PM2.5)

#Se contruyen los intervalos
intervalos<-cut(Frecuencia_PM2.5$PM2.5,breaks = seq(min(Frecuencia_PM2.5$PM2.5, na.rm = T),max(Frecuencia_PM2.5$PM2.5, na.rm = T),(max(Frecuencia_PM2.5$PM2.5, na.rm = T)-min(Frecuencia_PM2.5$PM2.5, na.rm = T))/k),right = F, na.rm = T, include.lowest = TRUE)

#Se le adjuntan los intervalos a la tabla que tenemos de anomalia y de region
Frecuencia_PM2.5<-Frecuencia_PM2.5%>%mutate(IntervaloPM2=intervalos)

#Se genera la tabla de frecuencias

FA<-table(Frecuencia_PM2.5$IntervaloPM2,Frecuencia_PM2.5$station)
#FA<-prop.table(FA)
#Se coloca la matriz en un Data Frame
FA<-as.data.frame(FA)
FA<-FA%>%spread(Var2,Freq)
FA<-rbind(FA, c("Total",colSums(Filter(is.numeric, FA))))


#Se contruye la tabla que va ser pasada a latex
print(xtable(FA, type = "latex", tabular.environment="longtable"),include.rownames=FALSE, file = "frecuenciasPM2.tex")

#Se elimina la tabla que tiene las frecuencias segun temperatura y anomalia
rm(FA,Frecuencia_PM2.5,intervalos)



```




















# Modelling
```{r}
#We are going to use dlmModReg, and dlmMLE

#We estimate the mean by day of the variables
df_contamination <- data%>%group_by(station,YM)%>%summarise("PM2.5"=mean(PM2.5,na.rm=TRUE),
                "SO2"=mean(SO2,na.rm=TRUE),
                "NO2"=mean(NO2,na.rm=TRUE),
                "CO"=mean(CO,na.rm=TRUE),
                "O3"=mean(O3,na.rm=TRUE),
                "TEMP"=mean(TEMP,na.rm=TRUE),
                "PRES"=mean(PRES,na.rm=TRUE),
                "DEWP"=mean(DEWP,na.rm=TRUE),
                "RAIN"=mean(RAIN,na.rm=TRUE),
                "WSPM"=mean(WSPM,na.rm=TRUE))
```




```{r}
#With this function you can construct
#the regression dynamic linear model
#u is the parameters
#df_variables is a matrix or data frame
#with the information of covariables
#this is need to be order in the same
#way that time serie that you want to model
build_model <- function (df_variables,u){
        u <- exp(u)
        dlmModReg(df_variables,
         dV = u[1],dW = u[2:length(u)])
}


#For estimate the AIC
dlm_aic <- function(loglik,coef){
    2*loglik+2*sum(coef)
}


#We create a function to select the best model
#using AIC criteria
#This function produce a data frame with the
#log diffs of the data
#df is a data frame with the numeric information
#that you want to estimate log first difference
#station is a string with the name
#of the station that you want to model
diff_variables <- function(df,station){
        df <- df%>%filter(station == station)
        
        df <-df%>%
        mutate("YM"=format(as.Date(Date,
        "%Y-%m-%d"),"%Y-%m"))
        
        df <- df%>%
        group_by(Date)%>%
        summarise("PM2.5"=mean(PM2.5,na.rm=TRUE),
                "SO2"=mean(SO2,na.rm=TRUE),
                "NO2"=mean(NO2,na.rm=TRUE),
                "CO"=mean(CO,na.rm=TRUE),
                "O3"=mean(O3,na.rm=TRUE),
                "TEMP"=mean(TEMP,na.rm=TRUE),
                "PRES"=mean(PRES,na.rm=TRUE),
                "DEWP"=mean(DEWP,na.rm=TRUE),
                "RAIN"=mean(RAIN,na.rm=TRUE),
                "WSPM"=mean(WSPM,na.rm=TRUE))
        name_cols <- colnames(df)
        columns <- ncol(df)
        #print(columns)
        for(i in 2:columns){
            df <- df%>%
            mutate(name = log(as.numeric(unlist(df[,i])))-
            log(as.numeric(unlist(lag(df[,i])))))
            colnames(df)[ncol(df)] <- paste("diff",
            name_cols[i],sep = "_")
            #print(head(df))
        }
        df[is.na(df)]<- NA
        df[] <- lapply(df, function(i) if(is.numeric(i))
         ifelse(is.infinite(i), NA, i) else i)
        df[] <- lapply(df, function(i) if(is.numeric(i)) 
        ifelse(is.infinite(-i), NA, i) else i)
        return(df[-1,])

        
}

#Select forward using the AIC
#df is a data frame with the information
#of all stations
#station is a string with the name
#of the station that you want to model
best_dlm <- function(df,station){
    df <- diff_variables(df,station)
    name_columns <- colnames(df)
    name_columns <- grepl("diff_",name_columns)
    df <- df[,name_columns]
    name_columns <- colnames(df)
    

    df_for_forecast <- df[,
    !(name_columns%in%c("diff_PM2.5"))]
    print(head(df_for_forecast))
    
    n_columns <- ncol(df_for_forecast)
    name_columns <- colnames(df_for_forecast)
    
    model_selected <-character()
    fn <- function(aux){
        aux <- c(aux,model_selected)
        df_auxiliar <- df_for_forecast%>%select(aux)
        aic <- tryCatch(return(dlm_aic(dlmLL(df$diff_PM2.5,
        dlmModReg(df_auxiliar)),
        length(aux)+1)),
        error = function(e){return(NA)})
        return(aic)
    }

    for(i in 1:n_columns){
        if(i == 1){#For take the first covariable
            aic_aux <- sapply(name_columns,FUN = fn)
            aic <- min(aic_aux,na.rm = TRUE)
            print(aic)
            variable_selected <- which(aic_aux == aic)[1]
            model_selected <- name_columns[variable_selected]
            name_columns <- name_columns[-variable_selected]
            
        }else{#For select the rest of covariables when 
        #there is one selected
            aic_aux <- sapply(name_columns,FUN = fn)
            aic_aux[is.infinite(-aic_aux)] <- NA
            aic_aux[is.infinite(aic_aux)] <- NA
            #print(aic_aux)
            if(aic>min(aic_aux, na.rm =TRUE)){
                aic <- min(aic_aux, na.rm =TRUE)
                variable_selected <- which(aic_aux == aic)[1]
                model_selected <- c(model_selected,
                name_columns[variable_selected])
                name_columns <- name_columns[-variable_selected]
            }else{
                break
            }
        }
    }
    model_selected <- paste(model_selected,
    collapse = "+")#String with the form of the model
    return(paste(model_selected,aic,sep = " "))
}








#Data frame with the selection of the model
df_adjustements <- data.frame("Station"=character(),
"Model_AIC"=character())

#Estimating the best dlm
for(i in 1:length(stations)){
    df_adjustements[i,1] <- stations[i]
    df_station <- data%>%filter(station == stations[i])
    df_adjustements[i,2] <- best_dlm(df_station,stations[i])
    print(best_dlm(df_station,stations[i]))
}
df_adjustements[,1] <- stations #Name of stations
df_adjustements <- df_adjustements%>%
separate(Model_AIC, c("Modelo","AIC"),sep = " ") #Naming columns
print(xtable(df_adjustements, 
    type = "latex",
    tabular.environment="longtable"),
    include.rownames=FALSE,
     file = "ajustes.tex") #Create table latex



#We are going to forecast with the model
#We note that all the models select as best model the model with the pressure
#We do one step a head forecast
stations_original <- stations
stations <- stations_original
df_forecast <- data.frame("Date" =character(),
 "Real" = numeric(),
  "Forecast" = numeric(),
  "Superior" = numeric(),
  "Inferior" = numeric(),
  "station" = character())


#tail(df_forecast)
stations <-stations[!(stations %in%
 c("Dingling","Nongzhanguan"))] #These were not adjusted because generates problems

#We detected that with SO2 the give problem so we discarded this variables
for(i in 1:length(stations)){
    df_station <- data%>%filter(station == stations[i])
    df_station <- diff_variables(df_station)
    df_for_forecast <- df_station
    #df_for_forecast <- df_station[-seq(nrow(df_station)-9, nrow(df_station), by = 1),]
    variables <- df_adjustements$Modelo[df_adjustements$Station == stations[i]]
    variables <- unlist(strsplit(variables,split = "+",fixed = TRUE))
    variables <- variables[variables != "diff_SO2"]
    variables <- df_for_forecast%>%select(variables)
    build_model <- function (u){
        u <- exp(u)
        dlmModReg(variables, dV = u[1],dW = u[2:length(u)])
    }
    
    outMLE <- dlmMLE(df_for_forecast$diff_PM2.5,
    parm =rep(0,ncol(variables)+2),
    build_model)#Estimate the MLE
    model_builded <- build_model(outMLE$par)
    dlm_filtered <- dlmFilter(df_for_forecast$diff_PM2.5,
    model_builded) #The forecasting one step ahead
    assign(paste("dlm_filtered",i,sep = "_"),
    dlm_filtered) #Save the filtered
    #conf <- unlist(dlmSvd2var(dlm_filtered$U.C,
    #dlm_filtered$D.C))[-1]
    sdev <- residuals(dlm_filtered)$sd
    filtered <- dlm_filtered$f #Forecast
    #The next are prediction intervals
    superior <-filtered+qnorm(0.025)*sdev
    inferior <-filtered-qnorm(0.025)*sdev
    df_aux <- data.frame("Date" = df_station$Date,
     "Real" = df_station$diff_PM2.5,
     "Forecast" = filtered,
     "Superior"=superior,
     "Inferior"=inferior,
     "station" = rep(stations[i],
     nrow(df_station)))
    df_forecast <- rbind(df_forecast,
    df_aux)  
}

#We save the estimation
write.csv(file = "adjust_1.csv",df_forecast)
```

We proceed to graph the models and predictions
```{r}
#We are going to plot by station
library(scales)

df_forecast <- df_forecast%>%gather(key = "Tipo",value = "Valor", 2:3)
df_forecast$Date <- as.Date(paste(df_forecast$Date,"1",sep = "-"))
sum(is.na(df_forecast$Valor))
cbbPalette <- c("#000000", "#E69F00")

for(i in stations){
    ggsave(filename=paste("times_serie_2","_",i,".pdf",sep=""),
    df_forecast%>%filter(station== i)%>%
    ggplot(aes(x=Date,y=Valor, color = Tipo))+
    geom_line(alpha=0.7)+
    scale_x_date(date_labels = "%Y-%m")+
    scale_color_brewer(palette="Set1")+
    ylab("Diferencia logPM2.5")+
    ggtitle(i)+
    xlab("Fecha")+
    theme_minimal()+
    theme(text=element_text(size=24)),width=20,height=5)
}


df_10_last_days <- df_forecast%>%filter(Date>"2017-02-19")
for(i in stations){
    ggsave(filename=paste("times_serie_10_last_days","_",i,".pdf",sep=""),
    df_10_last_days%>%filter(station== i)%>%
    ggplot(aes(x=Date))+
    geom_ribbon(aes(ymin=Inferior,ymax=Superior,
    fill="Intervalo de predicción 95%"),alpha = 0.3)+
    geom_line(aes(y=Valor, color = Tipo))+
    scale_color_brewer(palette="Set1")+
    scale_fill_manual(values =  "grey70",name ="")+
    ylab("Diferencia logPM2.5")+ggtitle(i)+xlab("Fecha")+
    theme_minimal()+
    theme(text=element_text(size=24)),width=20,height=5)
}


```




```{r}
#Check of hypothesis
stations<- unique(df_forecast$station)
for(i in 1:length(stations)){
    #Save qqplot
    pdf(paste("qqplot",stations[i],".pdf",sep = ""))
    qqnorm(residuals(get(paste("dlm_filtered",i,sep="_")),
    sd=FALSE))
    qqline(residuals(get(paste("dlm_filtered",i,sep="_")),
    sd=FALSE))
    dev.off() 
    tsdiag(get(paste("dlm_filtered",i,sep="_")) #For
    #diagnostics
}


```

```{r}

df_MSE <- data.frame("Estación"=character(),"MSE" = numeric())
for(i in 1:length(stations)){
    df_aux <- df_forecast%>%filter(station == stations[i])
    valor_real <- df_aux%>%filter(Tipo == "Real")
    valor_forecast <- df_aux%>%filter(Tipo == "Forecast")
    MSE <- mean((valor_forecast$Valor-valor_real$Valor)^2,na.rm=TRUE)
    df_MSE_aux <- data.frame("Estación"=stations[i],"MSE" = MSE)
    df_MSE <- rbind(df_MSE,df_MSE_aux)
}

print(xtable(df_MSE, type = "latex", tabular.environment="longtable"),
    include.rownames=FALSE, file = "MSE.tex")
```